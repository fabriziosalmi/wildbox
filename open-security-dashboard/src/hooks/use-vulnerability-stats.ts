/**
 * Custom React Query hook for fetching Guardian vulnerability statistics
 * 
 * This hook provides type-safe access to vulnerability stats from the Guardian service
 * with proper loading, error, and empty state handling.
 * 
 * @example
 * ```tsx
 * const { data, isLoading, isError, error } = useVulnerabilityStats()
 * 
 * if (isLoading) return <Skeleton />
 * if (isError) return <ErrorCard error={error} />
 * if (!data || data.total_vulnerabilities === 0) return <EmptyState />
 * 
 * return <StatsDisplay stats={data} />
 * ```
 */

import { useQuery, UseQueryResult } from '@tanstack/react-query'
import { guardianClient, getGuardianPath } from '@/lib/api-client'
import { useAuth } from '@/components/auth-provider'

/**
 * Vulnerability statistics returned from Guardian API
 * Matches the backend VulnerabilityStatsSerializer schema
 */
export interface VulnerabilityStats {
  // Total counts
  total_vulnerabilities: number
  
  // Severity breakdown
  critical_count: number
  high_count: number
  medium_count: number
  low_count: number
  info_count: number
  
  // Status breakdown
  open_count: number
  in_progress_count: number
  resolved_count: number
  
  // Due date tracking
  overdue_count: number
  due_today_count: number
  due_this_week_count: number
  
  // Metrics
  avg_risk_score: number
  avg_resolution_time_days: number
}

/**
 * Default empty stats object for initialization and fallback
 */
const DEFAULT_STATS: VulnerabilityStats = {
  total_vulnerabilities: 0,
  critical_count: 0,
  high_count: 0,
  medium_count: 0,
  low_count: 0,
  info_count: 0,
  open_count: 0,
  in_progress_count: 0,
  resolved_count: 0,
  overdue_count: 0,
  due_today_count: 0,
  due_this_week_count: 0,
  avg_risk_score: 0,
  avg_resolution_time_days: 0,
}

/**
 * Fetch vulnerability statistics from Guardian API
 * 
 * @returns Promise resolving to VulnerabilityStats
 * @throws ApiError if request fails
 */
async function fetchVulnerabilityStats(): Promise<VulnerabilityStats> {
  // Corrected API path after Phase 1.5 URL routing fix
  const path = getGuardianPath('/api/v1/vulnerabilities/stats/')
  
  console.log('üîç Fetching vulnerability stats from:', path)
  
  const response = await guardianClient.get(path)
  
  // Validate and normalize response data
  const stats: VulnerabilityStats = {
    total_vulnerabilities: response.total_vulnerabilities ?? 0,
    critical_count: response.critical_count ?? 0,
    high_count: response.high_count ?? 0,
    medium_count: response.medium_count ?? 0,
    low_count: response.low_count ?? 0,
    info_count: response.info_count ?? 0,
    open_count: response.open_count ?? 0,
    in_progress_count: response.in_progress_count ?? 0,
    resolved_count: response.resolved_count ?? 0,
    overdue_count: response.overdue_count ?? 0,
    due_today_count: response.due_today_count ?? 0,
    due_this_week_count: response.due_this_week_count ?? 0,
    avg_risk_score: response.avg_risk_score ?? 0,
    avg_resolution_time_days: response.avg_resolution_time_days ?? 0,
  }
  
  console.log('‚úÖ Vulnerability stats loaded:', stats)
  return stats
}

/**
 * Custom hook for vulnerability statistics with intelligent caching
 * 
 * Features:
 * - Automatic authentication state handling
 * - Client-side only execution (prevents SSR hydration issues)
 * - Intelligent retry logic (disabled to prevent error loops)
 * - 30-second stale time (fresh data without excessive requests)
 * - 5-minute garbage collection time
 * - Disabled refetch on window focus (prevents unnecessary API calls)
 * 
 * @returns UseQueryResult with VulnerabilityStats data
 */
export function useVulnerabilityStats(): UseQueryResult<VulnerabilityStats, Error> {
  const { isAuthenticated, isLoading: authLoading } = useAuth()
  
  return useQuery<VulnerabilityStats, Error>({
    queryKey: ['vulnerabilityStats'],
    queryFn: fetchVulnerabilityStats,
    
    // Only fetch when:
    // 1. Running in browser (not SSR)
    // 2. User is authenticated
    // 3. Auth check is complete
    enabled: typeof window !== 'undefined' && isAuthenticated && !authLoading,
    
    // Disable automatic retries to prevent error loops
    // If the API is down, we don't want to hammer it
    retry: false,
    
    // Consider data fresh for 30 seconds
    // Reduces unnecessary API calls for frequently accessed data
    staleTime: 30000,
    
    // Keep unused data in cache for 5 minutes
    // Allows quick navigation back without refetching
    gcTime: 300000,
    
    // Don't refetch when user returns to tab
    // Stats don't change frequently enough to warrant this
    refetchOnWindowFocus: false,
    
    // Provide default data during initial load
    // Prevents undefined errors in consuming components
    placeholderData: DEFAULT_STATS,
  })
}

/**
 * Helper function to check if stats represent an empty state
 * 
 * @param stats - VulnerabilityStats object or undefined
 * @returns true if no vulnerabilities exist
 */
export function isEmptyStats(stats: VulnerabilityStats | undefined): boolean {
  return !stats || stats.total_vulnerabilities === 0
}

/**
 * Helper function to calculate total active vulnerabilities (excluding resolved)
 * 
 * @param stats - VulnerabilityStats object
 * @returns number of active vulnerabilities
 */
export function getActiveCount(stats: VulnerabilityStats): number {
  return stats.open_count + stats.in_progress_count
}

/**
 * Helper function to get severity distribution as percentage
 * 
 * @param stats - VulnerabilityStats object
 * @returns object with severity percentages
 */
export function getSeverityDistribution(stats: VulnerabilityStats): {
  critical: number
  high: number
  medium: number
  low: number
  info: number
} {
  const total = stats.total_vulnerabilities || 1 // Avoid division by zero
  
  return {
    critical: Math.round((stats.critical_count / total) * 100),
    high: Math.round((stats.high_count / total) * 100),
    medium: Math.round((stats.medium_count / total) * 100),
    low: Math.round((stats.low_count / total) * 100),
    info: Math.round((stats.info_count / total) * 100),
  }
}
