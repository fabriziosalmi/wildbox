import asyncio
import logging
import re
from datetime import datetime, timedelta
from typing import Dict, Any, List, Optional
import random

from schemas import VulnDbScannerRequest, VulnDbScannerResponse, VulnerabilityInfo

logger = logging.getLogger(__name__)

TOOL_INFO = {
    "name": "Vulnerability Database Scanner",
    "description": "Comprehensive vulnerability scanner using multiple security databases",
    "version": "1.0.0",
    "author": "Wildbox Security",
    "category": "vulnerability_assessment",
    "tags": ["vulnerability", "cve", "security-assessment", "risk-analysis"]
}

# Simulated vulnerability database
VULNERABILITY_DATABASE = {
    "apache": [
        {
            "cve_id": "CVE-2021-44228",
            "title": "Apache Log4j2 Remote Code Execution",
            "description": "Apache Log4j2 2.0-beta9 through 2.15.0 JNDI features used in configuration, log messages, and parameters do not protect against attacker controlled LDAP and other JNDI related endpoints.",
            "severity": "critical",
            "cvss_score": 10.0,
            "published_date": "2021-12-10",
            "last_modified": "2021-12-14",
            "affected_products": ["Apache Log4j", "Elasticsearch", "Solr"],
            "references": ["https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-44228"],
            "exploit_available": True,
            "exploit_info": {
                "exploit_type": "Remote Code Execution",
                "complexity": "Low",
                "public_exploits": True
            }
        },
        {
            "cve_id": "CVE-2022-22965",
            "title": "Spring Framework Remote Code Execution",
            "description": "A Spring MVC or Spring WebFlux application running on JDK 9+ may be vulnerable to remote code execution (RCE) via data binding on a specially crafted request.",
            "severity": "critical",
            "cvss_score": 9.8,
            "published_date": "2022-04-01",
            "last_modified": "2022-04-05",
            "affected_products": ["Spring Framework", "Spring Boot"],
            "references": ["https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-22965"],
            "exploit_available": True,
            "exploit_info": {
                "exploit_type": "Remote Code Execution",
                "complexity": "Medium",
                "public_exploits": True
            }
        }
    ],
    "nginx": [
        {
            "cve_id": "CVE-2021-23017",
            "title": "nginx DNS Resolver Off-by-one Heap Write",
            "description": "A security issue in nginx resolver was identified, which might allow an attacker who is able to forge UDP packets from the DNS server to cause 1-byte memory overwrite, resulting in worker process crash or potential other impact.",
            "severity": "high",
            "cvss_score": 8.1,
            "published_date": "2021-05-25",
            "last_modified": "2021-06-01",
            "affected_products": ["nginx"],
            "references": ["https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-23017"],
            "exploit_available": False,
            "exploit_info": None
        }
    ],
    "wordpress": [
        {
            "cve_id": "CVE-2022-21661",
            "title": "WordPress SQL Injection",
            "description": "WordPress is affected by a SQL injection vulnerability in WP_Query when processing meta queries with ordering.",
            "severity": "high",
            "cvss_score": 7.5,
            "published_date": "2022-02-11",
            "last_modified": "2022-02-15",
            "affected_products": ["WordPress"],
            "references": ["https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-21661"],
            "exploit_available": True,
            "exploit_info": {
                "exploit_type": "SQL Injection",
                "complexity": "Medium",
                "public_exploits": False
            }
        }
    ],
    "mysql": [
        {
            "cve_id": "CVE-2022-21595",
            "title": "MySQL Server Information Disclosure",
            "description": "Vulnerability in the MySQL Server product of Oracle MySQL (component: C API). Supported versions that are affected are 5.7.35 and prior and 8.0.26 and prior.",
            "severity": "medium",
            "cvss_score": 6.5,
            "published_date": "2022-10-19",
            "last_modified": "2022-10-25",
            "affected_products": ["MySQL Server"],
            "references": ["https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-21595"],
            "exploit_available": False,
            "exploit_info": None
        }
    ]
}

# CVE database for direct CVE lookups
CVE_DATABASE = {
    "CVE-2021-44228": VULNERABILITY_DATABASE["apache"][0],
    "CVE-2022-22965": VULNERABILITY_DATABASE["apache"][1],
    "CVE-2021-23017": VULNERABILITY_DATABASE["nginx"][0],
    "CVE-2022-21661": VULNERABILITY_DATABASE["wordpress"][0],
    "CVE-2022-21595": VULNERABILITY_DATABASE["mysql"][0]
}


def normalize_target(target: str) -> str:
    """Normalize target string for database lookup."""
    return target.lower().strip()


async def search_by_software(target: str, severity_filter: List[str], max_results: int) -> List[Dict[str, Any]]:
    """Search vulnerabilities by software name."""
    await asyncio.sleep(0.2)  # Simulate database query
    
    normalized_target = normalize_target(target)
    vulnerabilities = []
    
    # Search in database
    for software, vulns in VULNERABILITY_DATABASE.items():
        if software in normalized_target or normalized_target in software:
            for vuln in vulns:
                if vuln["severity"] in severity_filter:
                    vulnerabilities.append(vuln)
    
    # Generate additional synthetic vulnerabilities for demo
    if vulnerabilities and len(vulnerabilities) < max_results:
        synthetic_vulns = generate_synthetic_vulnerabilities(normalized_target, max_results - len(vulnerabilities))
        vulnerabilities.extend(synthetic_vulns)
    
    return vulnerabilities[:max_results]


async def search_by_cve(cve_id: str) -> Optional[Dict[str, Any]]:
    """Search vulnerability by CVE ID."""
    await asyncio.sleep(0.1)  # Simulate database query
    
    cve_id = cve_id.upper().strip()
    return CVE_DATABASE.get(cve_id)


async def comprehensive_scan(target: str, severity_filter: List[str], max_results: int) -> List[Dict[str, Any]]:
    """Perform comprehensive vulnerability scan."""
    await asyncio.sleep(0.5)  # Simulate comprehensive analysis
    
    vulnerabilities = []
    normalized_target = normalize_target(target)
    
    # Search across all software types
    for software, vulns in VULNERABILITY_DATABASE.items():
        for vuln in vulns:
            if vuln["severity"] in severity_filter:
                # Add if target matches or is related
                if (software in normalized_target or 
                    normalized_target in software or
                    any(product.lower() in normalized_target for product in vuln["affected_products"])):
                    vulnerabilities.append(vuln)
    
    # Add synthetic vulnerabilities for comprehensive results
    if len(vulnerabilities) < max_results:
        synthetic_vulns = generate_synthetic_vulnerabilities(normalized_target, max_results - len(vulnerabilities))
        vulnerabilities.extend(synthetic_vulns)
    
    return vulnerabilities[:max_results]


def generate_synthetic_vulnerabilities(target: str, count: int) -> List[Dict[str, Any]]:
    """Generate synthetic vulnerabilities for demonstration."""
    synthetic_vulns = []
    
    severities = ["critical", "high", "medium", "low"]
    vuln_types = [
        "SQL Injection", "Cross-Site Scripting", "Remote Code Execution",
        "Authentication Bypass", "Information Disclosure", "Privilege Escalation",
        "Buffer Overflow", "Directory Traversal", "CSRF", "Insecure Deserialization"
    ]
    
    for i in range(count):
        severity = random.choice(severities)
        vuln_type = random.choice(vuln_types)
        cve_year = random.randint(2020, 2023)
        cve_num = random.randint(10000, 99999)
        
        cvss_ranges = {
            "critical": (9.0, 10.0),
            "high": (7.0, 8.9),
            "medium": (4.0, 6.9),
            "low": (0.1, 3.9)
        }
        
        cvss_score = round(random.uniform(*cvss_ranges[severity]), 1)
        
        synthetic_vuln = {
            "cve_id": f"CVE-{cve_year}-{cve_num}",
            "title": f"{target.title()} {vuln_type} Vulnerability",
            "description": f"A {severity} severity {vuln_type.lower()} vulnerability was discovered in {target}. This vulnerability could allow attackers to compromise the system.",
            "severity": severity,
            "cvss_score": cvss_score,
            "published_date": (datetime.now() - timedelta(days=random.randint(30, 365))).strftime("%Y-%m-%d"),
            "last_modified": (datetime.now() - timedelta(days=random.randint(1, 30))).strftime("%Y-%m-%d"),
            "affected_products": [target.title()],
            "references": [f"https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-{cve_year}-{cve_num}"],
            "exploit_available": random.choice([True, False]),
            "exploit_info": {
                "exploit_type": vuln_type,
                "complexity": random.choice(["Low", "Medium", "High"]),
                "public_exploits": random.choice([True, False])
            } if random.choice([True, False]) else None
        }
        
        synthetic_vulns.append(synthetic_vuln)
    
    return synthetic_vulns


def calculate_severity_breakdown(vulnerabilities: List[Dict[str, Any]]) -> Dict[str, int]:
    """Calculate severity breakdown statistics."""
    breakdown = {"critical": 0, "high": 0, "medium": 0, "low": 0}
    
    for vuln in vulnerabilities:
        severity = vuln.get("severity", "unknown")
        if severity in breakdown:
            breakdown[severity] += 1
    
    return breakdown


def assess_risk(vulnerabilities: List[Dict[str, Any]], severity_breakdown: Dict[str, int]) -> Dict[str, Any]:
    """Assess overall risk based on vulnerabilities found."""
    total_vulns = len(vulnerabilities)
    
    if total_vulns == 0:
        risk_level = "Low"
        risk_score = 0
    else:
        # Calculate weighted risk score
        weights = {"critical": 10, "high": 7, "medium": 4, "low": 1}
        risk_score = sum(severity_breakdown[sev] * weights[sev] for sev in weights)
        
        if risk_score >= 50:
            risk_level = "Critical"
        elif risk_score >= 25:
            risk_level = "High"
        elif risk_score >= 10:
            risk_level = "Medium"
        else:
            risk_level = "Low"
    
    # Count exploitable vulnerabilities
    exploitable_count = sum(1 for vuln in vulnerabilities if vuln.get("exploit_available", False))
    
    assessment = {
        "overall_risk_level": risk_level,
        "risk_score": risk_score,
        "total_vulnerabilities": total_vulns,
        "exploitable_vulnerabilities": exploitable_count,
        "exploit_ratio": round(exploitable_count / total_vulns * 100, 1) if total_vulns > 0 else 0,
        "most_severe": severity_breakdown.get("critical", 0) + severity_breakdown.get("high", 0),
        "recommendations_priority": "Immediate" if risk_level in ["Critical", "High"] else "Scheduled"
    }
    
    return assessment


def generate_recommendations(vulnerabilities: List[Dict[str, Any]], risk_assessment: Dict[str, Any]) -> List[str]:
    """Generate security recommendations based on findings."""
    recommendations = []
    
    # Risk-based recommendations
    if risk_assessment["overall_risk_level"] == "Critical":
        recommendations.append("🚨 CRITICAL: Immediate patching required - vulnerabilities pose severe risk")
        recommendations.append("Deploy emergency security updates within 24 hours")
        recommendations.append("Consider taking affected systems offline until patched")
    elif risk_assessment["overall_risk_level"] == "High":
        recommendations.append("⚠️ HIGH PRIORITY: Schedule urgent patching within 72 hours")
        recommendations.append("Implement additional monitoring for affected systems")
    
    # Exploit-specific recommendations
    if risk_assessment["exploitable_vulnerabilities"] > 0:
        recommendations.append(f"🎯 {risk_assessment['exploitable_vulnerabilities']} vulnerabilities have known exploits - prioritize these patches")
        recommendations.append("Monitor for indicators of compromise related to known exploits")
    
    # Severity-specific recommendations
    critical_count = sum(1 for vuln in vulnerabilities if vuln["severity"] == "critical")
    if critical_count > 0:
        recommendations.append(f"Patch {critical_count} critical vulnerabilities immediately")
    
    high_count = sum(1 for vuln in vulnerabilities if vuln["severity"] == "high")
    if high_count > 0:
        recommendations.append(f"Address {high_count} high-severity vulnerabilities within one week")
    
    # General security recommendations
    recommendations.extend([
        "Implement automated vulnerability scanning in CI/CD pipeline",
        "Subscribe to security advisories for all software components",
        "Maintain an asset inventory with version tracking",
        "Establish a formal patch management process",
        "Regular security assessments and penetration testing"
    ])
    
    return recommendations


async def execute_tool(request: VulnDbScannerRequest) -> VulnDbScannerResponse:
    """Execute vulnerability database scanning."""
    try:
        logger.info(f"Starting vulnerability scan for target: {request.target}")
        
        vulnerabilities = []
        
        # Determine scan type and execute appropriate search
        if request.scan_type == "cve":
            # Direct CVE lookup
            if request.target.upper().startswith("CVE-"):
                vuln = await search_by_cve(request.target)
                if vuln and vuln["severity"] in request.severity_filter:
                    vulnerabilities = [vuln]
            else:
                raise ValueError("CVE scan type requires CVE ID (e.g., CVE-2021-44228)")
        
        elif request.scan_type == "software":
            # Software-based search
            vulnerabilities = await search_by_software(
                request.target, 
                request.severity_filter, 
                request.max_results
            )
        
        elif request.scan_type == "comprehensive":
            # Comprehensive scan
            vulnerabilities = await comprehensive_scan(
                request.target,
                request.severity_filter,
                request.max_results
            )
        
        else:
            raise ValueError(f"Invalid scan type: {request.scan_type}")
        
        # Filter vulnerabilities based on exploit preference
        if not request.include_exploits:
            vulnerabilities = [v for v in vulnerabilities if not v.get("exploit_available", False)]
        
        # Convert to VulnerabilityInfo objects
        vulnerability_objects = []
        for vuln in vulnerabilities:
            vuln_obj = VulnerabilityInfo(**vuln)
            vulnerability_objects.append(vuln_obj)
        
        # Calculate statistics and assessments
        severity_breakdown = calculate_severity_breakdown(vulnerabilities)
        risk_assessment = assess_risk(vulnerabilities, severity_breakdown)
        recommendations = generate_recommendations(vulnerabilities, risk_assessment)
        
        return VulnDbScannerResponse(
            target=request.target,
            scan_type=request.scan_type,
            vulnerabilities_found=vulnerability_objects,
            total_vulnerabilities=len(vulnerability_objects),
            severity_breakdown=severity_breakdown,
            risk_assessment=risk_assessment,
            recommendations=recommendations,
            scan_timestamp=datetime.now().isoformat(),
            success=True,
            message=f"Found {len(vulnerability_objects)} vulnerabilities for {request.target}"
        )
        
    except Exception as e:
        logger.error(f"Error in vulnerability scanner: {str(e)}")
        return VulnDbScannerResponse(
            target=request.target,
            scan_type=request.scan_type,
            vulnerabilities_found=[],
            total_vulnerabilities=0,
            severity_breakdown={"critical": 0, "high": 0, "medium": 0, "low": 0},
            risk_assessment={},
            recommendations=[],
            scan_timestamp=datetime.now().isoformat(),
            success=False,
            message=f"Vulnerability scan failed: {str(e)}"
        )
