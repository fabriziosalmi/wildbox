import re
import time
import base64
import hashlib
import math
import struct
import logging
from datetime import datetime
from typing import Dict, List, Any, Optional
import aiohttp
import asyncio

from schemas import (
    StaticMalwareAnalyzerInput,
    StaticMalwareAnalyzerOutput,
    MalwareSignature,
    SuspiciousBehavior,
    StringAnalysis,
    FileMetadata
)

# Configure logging
logger = logging.getLogger(__name__)

# Tool metadata
TOOL_INFO = {
    "name": "Static Malware Analyzer",
    "description": "Advanced static malware analysis tool using signature detection, behavioral analysis, string extraction, and entropy analysis",
    "category": "malware_analysis",
    "version": "1.0.0",
    "author": "Wildbox Security",
    "tags": ["malware", "static-analysis", "threat-detection", "yara", "pe-analysis"]
}

async def execute_tool(data: StaticMalwareAnalyzerInput) -> StaticMalwareAnalyzerOutput:
    """
    Perform static malware analysis on the provided file
    """
    start_time = time.time()
    
    file_data = None
    file_hash = data.file_hash
    
    try:
        # Get file data from various sources
        if data.file_content:
            file_data = base64.b64decode(data.file_content)
            file_hash = calculate_file_hashes(file_data)["sha256"]
        elif data.file_url:
            file_data = await download_file(data.file_url)
            if file_data:
                file_hash = calculate_file_hashes(file_data)["sha256"]
        elif data.file_hash:
            # For hash-only analysis, we'll do what we can without the actual file
            file_hash = data.file_hash
        
        # Initialize analysis results
        malware_signatures = []
        suspicious_behaviors = []
        string_analysis = []
        yara_matches = []
        file_metadata = None
        
        # Perform file metadata analysis if we have the file
        if file_data:
            file_metadata = analyze_file_metadata(file_data)
            
            if data.check_strings:
                string_analysis = extract_and_analyze_strings(file_data)
            
            if data.check_behaviors:
                suspicious_behaviors = analyze_behavioral_patterns(file_data, string_analysis)
            
            if data.check_signatures:
                malware_signatures = check_malware_signatures(file_data, file_hash)
            
            # Apply YARA rules if provided
            if data.yara_rules:
                yara_matches = apply_yara_rules(file_data, data.yara_rules)
        
        # Hash-based checks (can be done even without file content)
        if file_hash:
            hash_signatures = await check_hash_databases(file_hash)
            malware_signatures.extend(hash_signatures)
        
        # Classify threat
        threat_classification, threat_family, threat_score = classify_threat(
            malware_signatures,
            suspicious_behaviors,
            string_analysis,
            file_metadata
        )
        
        # Generate risk assessment
        risk_assessment = generate_risk_assessment(
            threat_classification,
            threat_score,
            malware_signatures,
            suspicious_behaviors
        )
        
        # Generate recommendations
        recommendations = generate_recommendations(
            threat_classification,
            threat_score,
            malware_signatures,
            suspicious_behaviors
        )
        
        return StaticMalwareAnalyzerOutput(
            file_hash=file_hash,
            analysis_timestamp=datetime.utcnow().isoformat(),
            analysis_depth=data.analysis_depth,
            file_metadata=file_metadata,
            malware_signatures=malware_signatures,
            suspicious_behaviors=suspicious_behaviors,
            string_analysis=string_analysis,
            threat_classification=threat_classification,
            threat_family=threat_family,
            threat_score=threat_score,
            risk_assessment=risk_assessment,
            yara_matches=yara_matches,
            av_detection_ratio=None,  # Would integrate with VirusTotal API
            recommendations=recommendations,
            execution_time=time.time() - start_time
        )
        
    except Exception as e:
        return StaticMalwareAnalyzerOutput(
            file_hash=file_hash,
            analysis_timestamp=datetime.utcnow().isoformat(),
            analysis_depth=data.analysis_depth,
            file_metadata=None,
            malware_signatures=[MalwareSignature(
                signature_name="Analysis Error",
                signature_type="Error",
                description=f"Analysis failed: {str(e)}",
                severity="High",
                confidence=1.0,
                details={"error": str(e)}
            )],
            suspicious_behaviors=[],
            string_analysis=[],
            threat_classification="Unknown",
            threat_family=None,
            threat_score=0.0,
            risk_assessment={"error": str(e)},
            yara_matches=[],
            recommendations=["Unable to complete analysis due to error"],
            execution_time=time.time() - start_time
        )

async def download_file(url: str) -> Optional[bytes]:
    """Download file from URL for analysis"""
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(url, timeout=30) as response:
                if response.status == 200:
                    return await response.read()
    except Exception:
        pass
    return None

def calculate_file_hashes(file_data: bytes) -> Dict[str, str]:
    """Calculate MD5, SHA1, and SHA256 hashes"""
    return {
        "md5": hashlib.md5(file_data).hexdigest(),
        "sha1": hashlib.sha1(file_data).hexdigest(),
        "sha256": hashlib.sha256(file_data).hexdigest()
    }

def analyze_file_metadata(file_data: bytes) -> FileMetadata:
    """Analyze file metadata and structure"""
    file_size = len(file_data)
    entropy = calculate_entropy(file_data)
    packed = entropy > 7.0  # High entropy suggests packing/compression
    
    # Detect file type
    file_type = detect_file_type(file_data)
    file_extension = get_file_extension(file_type)
    
    # PE analysis for Windows executables
    pe_info = None
    if file_type in ['PE32', 'PE32+']:
        pe_info = analyze_pe_structure(file_data)
    
    return FileMetadata(
        file_size=file_size,
        file_type=file_type,
        file_extension=file_extension,
        pe_info=pe_info,
        entropy=entropy,
        packed=packed,
        digital_signature=None  # Would implement digital signature verification
    )

def calculate_entropy(data: bytes) -> float:
    """Calculate Shannon entropy of file data"""
    if not data:
        return 0.0
    
    entropy = 0.0
    byte_counts = [0] * 256
    
    for byte in data:
        byte_counts[byte] += 1
    
    data_len = len(data)
    for count in byte_counts:
        if count > 0:
            probability = count / data_len
            entropy -= probability * math.log2(probability)
    
    return entropy

def detect_file_type(file_data: bytes) -> str:
    """Detect file type based on magic bytes"""
    if file_data.startswith(b'MZ'):
        return 'PE32'
    elif file_data.startswith(b'\x7fELF'):
        return 'ELF'
    elif file_data.startswith(b'PK\x03\x04'):
        return 'ZIP'
    elif file_data.startswith(b'%PDF'):
        return 'PDF'
    elif file_data.startswith(b'\x89PNG'):
        return 'PNG'
    elif file_data.startswith(b'\xff\xd8\xff'):
        return 'JPEG'
    else:
        return 'Unknown'

def get_file_extension(file_type: str) -> str:
    """Get typical file extension for file type"""
    extensions = {
        'PE32': '.exe',
        'PE32+': '.exe',
        'ELF': '',
        'ZIP': '.zip',
        'PDF': '.pdf',
        'PNG': '.png',
        'JPEG': '.jpg'
    }
    return extensions.get(file_type, '')

def analyze_pe_structure(file_data: bytes) -> Dict[str, Any]:
    """Analyze PE (Portable Executable) structure"""
    try:
        # Basic PE header parsing
        if len(file_data) < 64:
            return {}
        
        # Get PE header offset
        pe_offset = struct.unpack('<I', file_data[60:64])[0]
        
        if pe_offset + 24 > len(file_data):
            return {}
        
        # Parse basic PE information
        pe_info = {
            'pe_offset': pe_offset,
            'machine_type': struct.unpack('<H', file_data[pe_offset + 4:pe_offset + 6])[0],
            'number_of_sections': struct.unpack('<H', file_data[pe_offset + 6:pe_offset + 8])[0],
            'timestamp': struct.unpack('<I', file_data[pe_offset + 8:pe_offset + 12])[0],
            'characteristics': struct.unpack('<H', file_data[pe_offset + 22:pe_offset + 24])[0]
        }
        
        return pe_info
    except Exception:
        return {}

def extract_and_analyze_strings(file_data: bytes) -> List[StringAnalysis]:
    """Extract and analyze strings from file"""
    strings = []
    
    # Extract ASCII strings (minimum length 4)
    ascii_strings = re.findall(b'[\x20-\x7e]{4,}', file_data)
    
    # Extract Unicode strings
    unicode_strings = re.findall(b'(?:[\x20-\x7e]\x00){4,}', file_data)
    
    # Analyze strings
    for string_bytes in ascii_strings[:100]:  # Limit to first 100 strings
        try:
            string_value = string_bytes.decode('ascii')
            string_type, suspicious = classify_string(string_value)
            
            if string_type != "generic":  # Only include interesting strings
                strings.append(StringAnalysis(
                    string_type=string_type,
                    value=string_value[:100],  # Truncate long strings
                    context="ASCII string",
                    suspicious=suspicious,
                    confidence=0.8 if suspicious else 0.5
                ))
        except (UnicodeDecodeError, UnicodeError) as e:
            logger.debug(f"Error decoding string bytes: {e}")
            continue
    
    return strings

def classify_string(string_value: str) -> tuple:
    """Classify string type and determine if suspicious"""
    string_lower = string_value.lower()
    
    # URL patterns
    if re.match(r'https?://', string_value):
        return "URL", True
    
    # IP address patterns
    if re.match(r'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b', string_value):
        return "IP", True
    
    # Email patterns
    if re.match(r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}', string_value):
        return "Email", False
    
    # Registry patterns
    if 'hkey_' in string_lower or 'hklm' in string_lower or 'hkcu' in string_lower:
        return "Registry", True
    
    # File paths
    if ('\\windows\\' in string_lower or '/usr/' in string_lower or 
        'c:\\' in string_lower or '/tmp/' in string_lower):
        return "File", True
    
    # Suspicious commands
    suspicious_commands = [
        'cmd.exe', 'powershell', 'wget', 'curl', 'nc.exe', 'netcat',
        'taskkill', 'schtasks', 'reg.exe', 'regedit'
    ]
    if any(cmd in string_lower for cmd in suspicious_commands):
        return "Command", True
    
    # Cryptographic indicators
    crypto_indicators = ['aes', 'des', 'rsa', 'md5', 'sha1', 'sha256', 'base64']
    if any(indicator in string_lower for indicator in crypto_indicators):
        return "Crypto", False
    
    return "generic", False

def analyze_behavioral_patterns(file_data: bytes, strings: List[StringAnalysis]) -> List[SuspiciousBehavior]:
    """Analyze file for suspicious behavioral patterns"""
    behaviors = []
    
    # Network communication indicators
    network_indicators = [s for s in strings if s.string_type in ["URL", "IP"]]
    if network_indicators:
        behaviors.append(SuspiciousBehavior(
            behavior_name="Network Communication",
            category="Network",
            description="File contains network communication indicators",
            risk_level="Medium",
            indicators=[s.value for s in network_indicators[:5]],
            mitre_technique="T1071.001"
        ))
    
    # Registry modification indicators
    registry_indicators = [s for s in strings if s.string_type == "Registry"]
    if registry_indicators:
        behaviors.append(SuspiciousBehavior(
            behavior_name="Registry Modification",
            category="Registry",
            description="File contains registry modification indicators",
            risk_level="Medium",
            indicators=[s.value for s in registry_indicators[:5]],
            mitre_technique="T1112"
        ))
    
    # Command execution indicators
    command_indicators = [s for s in strings if s.string_type == "Command"]
    if command_indicators:
        behaviors.append(SuspiciousBehavior(
            behavior_name="Command Execution",
            category="Process",
            description="File contains command execution indicators",
            risk_level="High",
            indicators=[s.value for s in command_indicators[:5]],
            mitre_technique="T1059"
        ))
    
    # File system operations
    file_indicators = [s for s in strings if s.string_type == "File"]
    suspicious_paths = [s for s in file_indicators if any(
        path in s.value.lower() for path in ['temp', 'appdata', 'startup', 'system32']
    )]
    if suspicious_paths:
        behaviors.append(SuspiciousBehavior(
            behavior_name="Suspicious File Operations",
            category="File",
            description="File accesses suspicious system directories",
            risk_level="Medium",
            indicators=[s.value for s in suspicious_paths[:5]],
            mitre_technique="T1083"
        ))
    
    return behaviors

def check_malware_signatures(file_data: bytes, file_hash: str) -> List[MalwareSignature]:
    """Check file against known malware signatures"""
    signatures = []
    
    # Simple signature patterns (in real implementation, would use proper signature database)
    signature_patterns = {
        b'This program cannot be run in DOS mode': {
            'name': 'PE DOS Stub',
            'type': 'Heuristic',
            'description': 'Standard PE executable DOS stub',
            'severity': 'Low'
        },
        b'UPX': {
            'name': 'UPX Packer',
            'type': 'Heuristic', 
            'description': 'File packed with UPX packer',
            'severity': 'Medium'
        },
        b'CreateRemoteThread': {
            'name': 'Process Injection API',
            'type': 'Heuristic',
            'description': 'Contains process injection API calls',
            'severity': 'High'
        },
        b'VirtualAllocEx': {
            'name': 'Memory Allocation API',
            'type': 'Heuristic',
            'description': 'Contains memory allocation APIs used in injection',
            'severity': 'Medium'
        }
    }
    
    for pattern, info in signature_patterns.items():
        if pattern in file_data:
            signatures.append(MalwareSignature(
                signature_name=info['name'],
                signature_type=info['type'],
                description=info['description'],
                severity=info['severity'],
                confidence=0.7,
                details={'pattern': pattern.decode('ascii', errors='ignore')[:50]}
            ))
    
    return signatures

async def check_hash_databases(file_hash: str) -> List[MalwareSignature]:
    """Check file hash against malware databases"""
    signatures = []
    
    # In real implementation, would check against:
    # - VirusTotal API
    # - NSRL database
    # - Custom threat intelligence feeds
    
    # Simulate some known malicious hashes
    known_malicious_hashes = {
        '5d41402abc4b2a76b9719d911017c592': 'Known test malware sample',
        'e99a18c428cb38d5f260853678922e03': 'Trojan.Generic',
        '098f6bcd4621d373cade4e832627b4f6': 'Suspicious executable'
    }
    
    if file_hash.lower() in known_malicious_hashes:
        signatures.append(MalwareSignature(
            signature_name="Known Malicious Hash",
            signature_type="Hash",
            description=f"Hash matches known malware: {known_malicious_hashes[file_hash.lower()]}",
            severity="Critical",
            confidence=1.0,
            details={"hash": file_hash, "database": "threat_intelligence"}
        ))
    
    return signatures

def apply_yara_rules(file_data: bytes, yara_rules: List[str]) -> List[str]:
    """Apply YARA rules to file (simplified implementation)"""
    matches = []
    
    # In real implementation, would use python-yara library
    # This is a simplified simulation
    for rule in yara_rules:
        if 'malware' in rule.lower():
            matches.append(f"YARA rule matched: {rule[:50]}")
    
    return matches

def classify_threat(
    signatures: List[MalwareSignature],
    behaviors: List[SuspiciousBehavior],
    strings: List[StringAnalysis],
    metadata: Optional[FileMetadata]
) -> tuple:
    """Classify overall threat level and family"""
    threat_score = 0.0
    threat_family = None
    
    # Score based on signatures
    for sig in signatures:
        if sig.severity == "Critical":
            threat_score += 40
        elif sig.severity == "High":
            threat_score += 25
        elif sig.severity == "Medium":
            threat_score += 15
        elif sig.severity == "Low":
            threat_score += 5
    
    # Score based on behaviors
    for behavior in behaviors:
        if behavior.risk_level == "High":
            threat_score += 20
        elif behavior.risk_level == "Medium":
            threat_score += 10
        else:
            threat_score += 5
    
    # Score based on suspicious strings
    suspicious_strings = [s for s in strings if s.suspicious]
    threat_score += len(suspicious_strings) * 2
    
    # Score based on metadata
    if metadata and metadata.packed:
        threat_score += 15
    
    # Determine classification
    if threat_score >= 70:
        classification = "Malware"
    elif threat_score >= 40:
        classification = "Suspicious"
    elif threat_score >= 10:
        classification = "Unknown"
    else:
        classification = "Clean"
    
    # Simple threat family detection
    if any('trojan' in sig.description.lower() for sig in signatures):
        threat_family = "Trojan"
    elif any('ransomware' in sig.description.lower() for sig in signatures):
        threat_family = "Ransomware"
    elif any('backdoor' in sig.description.lower() for sig in signatures):
        threat_family = "Backdoor"
    
    return classification, threat_family, min(100.0, threat_score)

def generate_risk_assessment(
    classification: str,
    score: float,
    signatures: List[MalwareSignature],
    behaviors: List[SuspiciousBehavior]
) -> Dict[str, Any]:
    """Generate detailed risk assessment"""
    return {
        "overall_risk": classification,
        "threat_score": score,
        "infection_risk": "High" if classification == "Malware" else "Medium" if classification == "Suspicious" else "Low",
        "data_theft_risk": "High" if any(b.category == "Network" for b in behaviors) else "Low",
        "system_modification_risk": "High" if any(b.category in ["Registry", "File"] for b in behaviors) else "Low",
        "persistence_risk": "Medium" if any("startup" in str(b.indicators).lower() for b in behaviors) else "Low",
        "signature_confidence": sum(s.confidence for s in signatures) / len(signatures) if signatures else 0.0
    }

def generate_recommendations(
    classification: str,
    score: float,
    signatures: List[MalwareSignature],
    behaviors: List[SuspiciousBehavior]
) -> List[str]:
    """Generate security recommendations"""
    recommendations = []
    
    if classification == "Malware":
        recommendations.extend([
            "CRITICAL: Do not execute this file",
            "Quarantine or delete the file immediately",
            "Scan the entire system for additional malware",
            "Change all passwords if the file was executed",
            "Monitor network traffic for suspicious activity"
        ])
    elif classification == "Suspicious":
        recommendations.extend([
            "Exercise extreme caution with this file",
            "Run additional analysis tools before execution", 
            "Execute only in isolated/sandboxed environment",
            "Monitor system behavior during execution"
        ])
    elif classification == "Unknown":
        recommendations.extend([
            "File requires further analysis",
            "Consider dynamic analysis in sandbox",
            "Verify file source and authenticity"
        ])
    else:
        recommendations.append("File appears clean based on static analysis")
    
    # Specific recommendations based on findings
    if any(b.category == "Network" for b in behaviors):
        recommendations.append("Monitor network connections if file is executed")
    
    if any(b.category == "Registry" for b in behaviors):
        recommendations.append("Monitor registry changes if file is executed")
    
    recommendations.append("Consider submitting to additional analysis platforms")
    recommendations.append("Keep antivirus definitions updated")
    
    return recommendations

# Export tool info for registration
tool_info = TOOL_INFO
