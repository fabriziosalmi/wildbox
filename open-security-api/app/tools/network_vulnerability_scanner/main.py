"""
Network Vulnerability Scanner Tool

This tool performs comprehensive network vulnerability scanning including
port scanning, service detection, and vulnerability assessment.
"""

import asyncio
import socket
import time
import ipaddress
from datetime import datetime, timezone
from typing import Dict, List, Any, Optional, Tuple
import re

try:
    from .schemas import (
        NetworkVulnScanInput, NetworkVulnScanOutput, PortScanResult,
        VulnerabilityResult, HostInfo
    )
except ImportError:
    from schemas import (
        NetworkVulnScanInput, NetworkVulnScanOutput, PortScanResult,
        VulnerabilityResult, HostInfo
    )


class NetworkVulnerabilityScanner:
    """Network vulnerability scanner with comprehensive security assessment"""
    
    # Common vulnerable services and their default ports
    VULNERABLE_SERVICES = {
        21: {"service": "ftp", "vulns": ["Anonymous FTP", "Weak encryption"]},
        22: {"service": "ssh", "vulns": ["Weak authentication", "Outdated version"]},
        23: {"service": "telnet", "vulns": ["Unencrypted communication", "Weak authentication"]},
        25: {"service": "smtp", "vulns": ["Open relay", "Weak authentication"]},
        53: {"service": "dns", "vulns": ["DNS amplification", "Zone transfer"]},
        80: {"service": "http", "vulns": ["Unencrypted web traffic", "Web vulnerabilities"]},
        110: {"service": "pop3", "vulns": ["Unencrypted email", "Weak authentication"]},
        135: {"service": "rpc", "vulns": ["RPC vulnerabilities", "Information disclosure"]},
        139: {"service": "netbios", "vulns": ["SMB vulnerabilities", "Information disclosure"]},
        143: {"service": "imap", "vulns": ["Unencrypted email", "Weak authentication"]},
        443: {"service": "https", "vulns": ["Weak SSL/TLS", "Certificate issues"]},
        445: {"service": "smb", "vulns": ["SMB vulnerabilities", "Ransomware risk"]},
        993: {"service": "imaps", "vulns": ["Weak SSL/TLS", "Certificate issues"]},
        995: {"service": "pop3s", "vulns": ["Weak SSL/TLS", "Certificate issues"]},
        1433: {"service": "mssql", "vulns": ["Database vulnerabilities", "Weak authentication"]},
        3306: {"service": "mysql", "vulns": ["Database vulnerabilities", "Weak authentication"]},
        3389: {"service": "rdp", "vulns": ["RDP vulnerabilities", "Weak authentication"]},
        5432: {"service": "postgresql", "vulns": ["Database vulnerabilities", "Weak authentication"]},
        5900: {"service": "vnc", "vulns": ["VNC vulnerabilities", "Weak authentication"]},
        6379: {"service": "redis", "vulns": ["Unauthenticated access", "Code execution"]},
    }
    
    # High-risk ports that should typically be filtered
    HIGH_RISK_PORTS = [21, 23, 135, 139, 445, 1433, 3306, 3389, 5432, 5900, 6379]
    
    # Common port ranges for different scan types
    SCAN_PROFILES = {
        "quick": [21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 445, 993, 995, 3389],
        "full": list(range(1, 1025)),
        "stealth": [22, 80, 443, 8080, 8443],
        "aggressive": list(range(1, 65536))
    }
    
    def __init__(self):
        pass
    
    async def resolve_hostname(self, target: str) -> Tuple[str, Optional[str]]:
        """Resolve hostname to IP address"""
        try:
            # Check if target is already an IP address
            ipaddress.ip_address(target)
            return target, None
        except ValueError:
            pass
        
        try:
            # Resolve hostname
            ip = socket.gethostbyname(target)
            return ip, target
        except socket.gaierror:
            # Try to use as-is if it's a valid IP format
            try:
                ipaddress.ip_address(target)
                return target, None
            except ValueError:
                raise ValueError(f"Unable to resolve hostname: {target}")
    
    async def ping_host(self, ip: str) -> Tuple[bool, Optional[float]]:
        """Check if host is responsive"""
        try:
            start_time = time.time()
            # Try to connect to a commonly open port (80) with short timeout
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2)
            result = sock.connect_ex((ip, 80))
            sock.close()
            
            response_time = (time.time() - start_time) * 1000
            
            # Host is up if connection succeeded or was refused (port closed but host up)
            is_up = result in [0, 61, 111]  # 0: success, 61: connection refused, 111: connection refused
            
            return is_up, response_time if is_up else None
        except Exception:
            return False, None
    
    async def scan_port(self, ip: str, port: int, timeout: float = 1.0) -> PortScanResult:
        """Scan a single port"""
        try:
            start_time = time.time()
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            
            result = sock.connect_ex((ip, port))
            sock.close()
            
            if result == 0:
                # Port is open, try to get banner
                banner = await self.get_service_banner(ip, port)
                service_info = self.identify_service(port, banner)
                
                return PortScanResult(
                    port=port,
                    protocol="tcp",
                    state="open",
                    service=service_info.get("service"),
                    version=service_info.get("version"),
                    banner=banner
                )
            else:
                return PortScanResult(
                    port=port,
                    protocol="tcp",
                    state="closed",
                    service=None,
                    version=None,
                    banner=None
                )
        except Exception:
            return PortScanResult(
                port=port,
                protocol="tcp",
                state="filtered",
                service=None,
                version=None,
                banner=None
            )
    
    async def get_service_banner(self, ip: str, port: int, timeout: float = 2.0) -> Optional[str]:
        """Attempt to grab service banner"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            sock.connect((ip, port))
            
            # Send HTTP request for web services
            if port in [80, 8080, 8000]:
                sock.send(b"GET / HTTP/1.1\r\nHost: %s\r\n\r\n" % ip.encode())
            elif port == 443:
                # For HTTPS, just try to read without sending
                pass
            else:
                # For other services, just try to read
                pass
            
            banner = sock.recv(1024).decode('utf-8', errors='ignore').strip()
            sock.close()
            
            return banner if banner else None
        except Exception:
            return None
    
    def identify_service(self, port: int, banner: Optional[str]) -> Dict[str, Any]:
        """Identify service based on port and banner"""
        service_info = {"service": None, "version": None}
        
        # Check known services by port
        if port in self.VULNERABLE_SERVICES:
            service_info["service"] = self.VULNERABLE_SERVICES[port]["service"]
        
        # Analyze banner if available
        if banner:
            banner_lower = banner.lower()
            
            # HTTP services
            if "server:" in banner_lower:
                if "apache" in banner_lower:
                    service_info["service"] = "apache"
                    version_match = re.search(r'apache/([0-9.]+)', banner_lower)
                    if version_match:
                        service_info["version"] = version_match.group(1)
                elif "nginx" in banner_lower:
                    service_info["service"] = "nginx"
                    version_match = re.search(r'nginx/([0-9.]+)', banner_lower)
                    if version_match:
                        service_info["version"] = version_match.group(1)
                elif "iis" in banner_lower:
                    service_info["service"] = "iis"
            
            # SSH
            elif "ssh" in banner_lower:
                service_info["service"] = "ssh"
                version_match = re.search(r'openssh[_-]([0-9.]+)', banner_lower)
                if version_match:
                    service_info["version"] = version_match.group(1)
            
            # FTP
            elif "ftp" in banner_lower:
                service_info["service"] = "ftp"
                if "vsftpd" in banner_lower:
                    version_match = re.search(r'vsftpd ([0-9.]+)', banner_lower)
                    if version_match:
                        service_info["version"] = version_match.group(1)
        
        return service_info
    
    def check_vulnerabilities(self, open_ports: List[PortScanResult]) -> List[VulnerabilityResult]:
        """Check for common vulnerabilities based on open ports and services"""
        vulnerabilities = []
        
        for port_result in open_ports:
            if port_result.state != "open":
                continue
            
            port = port_result.port
            service = port_result.service or "unknown"
            
            # Check for high-risk ports
            if port in self.HIGH_RISK_PORTS:
                severity = "high" if port in [445, 3389, 1433, 3306] else "medium"
                vulnerabilities.append(VulnerabilityResult(
                    vuln_id=f"HIGHRISK-{port}",
                    severity=severity,
                    title=f"High-risk service on port {port}",
                    description=f"Port {port} ({service}) should typically be filtered from internet access",
                    affected_service=f"{service}:{port}",
                    cvss_score=7.5 if severity == "high" else 5.3,
                    cve_ids=[],
                    remediation=f"Filter port {port} from internet access or implement strong authentication"
                ))
            
            # Check specific service vulnerabilities
            if port in self.VULNERABLE_SERVICES:
                vulns = self.VULNERABLE_SERVICES[port]["vulns"]
                for vuln in vulns:
                    vulnerabilities.append(VulnerabilityResult(
                        vuln_id=f"SVC-{port}-{vulns.index(vuln)}",
                        severity="medium",
                        title=f"{vuln} on {service}",
                        description=f"Service {service} on port {port} may be vulnerable to {vuln.lower()}",
                        affected_service=f"{service}:{port}",
                        cvss_score=5.0,
                        cve_ids=[],
                        remediation=f"Review {service} configuration and apply security hardening"
                    ))
            
            # Check for unencrypted services
            unencrypted_ports = [21, 23, 25, 53, 80, 110, 143]
            if port in unencrypted_ports:
                vulnerabilities.append(VulnerabilityResult(
                    vuln_id=f"UNENC-{port}",
                    severity="low",
                    title=f"Unencrypted service on port {port}",
                    description=f"Service {service} transmits data in plaintext",
                    affected_service=f"{service}:{port}",
                    cvss_score=3.1,
                    cve_ids=[],
                    remediation=f"Implement encrypted alternative for {service} or use VPN"
                ))
            
            # Check for outdated service versions
            if port_result.version:
                # This is a simplified check - in reality, you'd compare against CVE databases
                try:
                    version_parts = port_result.version.split('.')
                    major_version = int(version_parts[0])
                    
                    # Example: Flag very old versions
                    if service == "apache" and major_version < 2:
                        vulnerabilities.append(VulnerabilityResult(
                            vuln_id=f"OLDVER-{port}",
                            severity="high",
                            title=f"Outdated {service} version",
                            description=f"{service} version {port_result.version} is outdated and may contain vulnerabilities",
                            affected_service=f"{service}:{port}",
                            cvss_score=8.1,
                            cve_ids=["CVE-2021-44228"],  # Example CVE
                            remediation=f"Update {service} to the latest stable version"
                        ))
                except (ValueError, IndexError):
                    pass
        
        return vulnerabilities
    
    def calculate_security_score(self, open_ports: List[PortScanResult], 
                                vulnerabilities: List[VulnerabilityResult]) -> Tuple[float, str]:
        """Calculate overall security score and risk level"""
        base_score = 100
        
        # Deduct points for open ports
        for port_result in open_ports:
            if port_result.state == "open":
                if port_result.port in self.HIGH_RISK_PORTS:
                    base_score -= 15
                else:
                    base_score -= 5
        
        # Deduct points for vulnerabilities
        for vuln in vulnerabilities:
            if vuln.severity == "critical":
                base_score -= 25
            elif vuln.severity == "high":
                base_score -= 15
            elif vuln.severity == "medium":
                base_score -= 8
            elif vuln.severity == "low":
                base_score -= 3
        
        # Ensure score doesn't go below 0
        score = max(0, base_score)
        
        # Determine risk level
        if score >= 80:
            risk_level = "low"
        elif score >= 60:
            risk_level = "medium"
        elif score >= 30:
            risk_level = "high"
        else:
            risk_level = "critical"
        
        return score, risk_level
    
    def generate_recommendations(self, open_ports: List[PortScanResult], 
                               vulnerabilities: List[VulnerabilityResult],
                               risk_level: str) -> List[str]:
        """Generate security recommendations"""
        recommendations = []
        
        # General recommendations based on risk level
        if risk_level == "critical":
            recommendations.append("URGENT: Address critical vulnerabilities immediately")
            recommendations.append("Consider taking affected systems offline until patched")
        elif risk_level == "high":
            recommendations.append("High-priority security issues detected - address promptly")
        
        # Port-specific recommendations
        high_risk_open = [p for p in open_ports if p.state == "open" and p.port in self.HIGH_RISK_PORTS]
        if high_risk_open:
            recommendations.append("Filter high-risk ports from internet access")
            recommendations.append("Implement network segmentation and access controls")
        
        # Service-specific recommendations
        open_services = set(p.service for p in open_ports if p.state == "open" and p.service)
        if "telnet" in open_services:
            recommendations.append("Replace Telnet with SSH for secure remote access")
        if "ftp" in open_services:
            recommendations.append("Replace FTP with SFTP or FTPS for secure file transfer")
        if "http" in open_services and "https" not in open_services:
            recommendations.append("Implement HTTPS to encrypt web traffic")
        
        # Vulnerability-based recommendations
        if vulnerabilities:
            recommendations.append("Apply security patches for identified vulnerabilities")
            recommendations.append("Implement intrusion detection and monitoring")
        
        # General security recommendations
        recommendations.extend([
            "Regularly update and patch all services",
            "Implement strong authentication mechanisms",
            "Use firewall rules to restrict unnecessary access",
            "Monitor network traffic for suspicious activity",
            "Conduct regular security assessments"
        ])
        
        return recommendations
    
    async def scan_target(self, target: str, scan_type: str = "quick", 
                         port_range: Optional[str] = None,
                         enable_service_detection: bool = True,
                         timeout: int = 300) -> Dict[str, Any]:
        """Perform comprehensive network vulnerability scan"""
        
        start_time = time.time()
        
        # Resolve target
        ip, hostname = await self.resolve_hostname(target)
        
        # Check if host is up
        is_up, response_time = await self.ping_host(ip)
        
        # Determine ports to scan
        if port_range:
            if '-' in port_range:
                start_port, end_port = map(int, port_range.split('-'))
                ports = list(range(start_port, end_port + 1))
            elif ',' in port_range:
                ports = [int(p.strip()) for p in port_range.split(',')]
            else:
                ports = [int(port_range)]
        else:
            ports = self.SCAN_PROFILES.get(scan_type, self.SCAN_PROFILES["quick"])
        
        # Scan ports
        scan_tasks = []
        for port in ports:
            scan_tasks.append(self.scan_port(ip, port, timeout=2.0))
        
        # Execute port scans with timeout
        try:
            port_results = await asyncio.wait_for(
                asyncio.gather(*scan_tasks, return_exceptions=True),
                timeout=timeout
            )
        except asyncio.TimeoutError:
            raise Exception(f"Scan timeout after {timeout} seconds")
        
        # Filter successful results
        open_ports = [result for result in port_results 
                     if isinstance(result, PortScanResult) and result.state == "open"]
        
        # Check for vulnerabilities
        vulnerabilities = self.check_vulnerabilities(port_results)
        
        # Calculate security score
        security_score, risk_level = self.calculate_security_score(open_ports, vulnerabilities)
        
        # Generate recommendations
        recommendations = self.generate_recommendations(open_ports, vulnerabilities, risk_level)
        
        scan_duration = time.time() - start_time
        
        return {
            "ip": ip,
            "hostname": hostname,
            "is_up": is_up,
            "response_time": response_time,
            "open_ports": open_ports,
            "vulnerabilities": vulnerabilities,
            "security_score": security_score,
            "risk_level": risk_level,
            "recommendations": recommendations,
            "scan_duration": scan_duration
        }


async def execute_tool(input_data: NetworkVulnScanInput) -> NetworkVulnScanOutput:
    """Execute the network vulnerability scanner tool"""
    
    try:
        scanner = NetworkVulnerabilityScanner()
        
        # Perform scan
        scan_results = await scanner.scan_target(
            input_data.target,
            input_data.scan_type,
            input_data.port_range,
            input_data.enable_service_detection,
            input_data.timeout
        )
        
        # Create host info
        host_info = HostInfo(
            ip_address=scan_results["ip"],
            hostname=scan_results["hostname"],
            os_guess=None,  # Would require additional tools like nmap
            mac_address=None,  # Would require local network access
            vendor=None,
            is_up=scan_results["is_up"],
            response_time=scan_results["response_time"]
        )
        
        return NetworkVulnScanOutput(
            success=True,
            target=input_data.target,
            scan_type=input_data.scan_type,
            host_info=host_info,
            open_ports=scan_results["open_ports"],
            vulnerabilities=scan_results["vulnerabilities"],
            security_score=scan_results["security_score"],
            risk_level=scan_results["risk_level"],
            scan_duration=scan_results["scan_duration"],
            recommendations=scan_results["recommendations"],
            scan_timestamp=datetime.now(timezone.utc)
        )
        
    except Exception as e:
        return NetworkVulnScanOutput(
            success=False,
            target=input_data.target,
            scan_type=input_data.scan_type,
            host_info=HostInfo(
                ip_address="",
                hostname=None,
                os_guess=None,
                mac_address=None,
                vendor=None,
                is_up=False,
                response_time=None
            ),
            open_ports=[],
            vulnerabilities=[],
            security_score=0.0,
            risk_level="unknown",
            scan_duration=0.0,
            recommendations=[],
            scan_timestamp=datetime.now(timezone.utc),
            error=str(e)
        )


# Tool metadata
TOOL_INFO = {
    "name": "network_vulnerability_scanner",
    "display_name": "Network Vulnerability Scanner",
    "description": "Comprehensive network vulnerability scanning with port detection and security assessment",
    "version": "1.0.0",
    "author": "Wildbox Security",
    "category": "network_security"
}


# For testing
if __name__ == "__main__":
    import asyncio
    
    async def test():
        test_input = NetworkVulnScanInput(
            target="scanme.nmap.org",
            scan_type="quick",
            enable_service_detection=True,
            check_common_vulns=True
        )
        
        result = await execute_tool(test_input)
        print(f"Network Scan Success: {result.success}")
        print(f"Target: {result.target}")
        print(f"Host Up: {result.host_info.is_up}")
        print(f"Open Ports: {len(result.open_ports)}")
        print(f"Vulnerabilities: {len(result.vulnerabilities)}")
        print(f"Security Score: {result.security_score}")
        print(f"Risk Level: {result.risk_level}")
    
    asyncio.run(test())
